---
output: gfm
default-image-extension: ""
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

# condathis <img src="man/figures/logo.png" align="right" height="138" alt="" />

<!-- badges: start -->
[![r-cmd-check](https://github.com/luciorq/condathis/actions/workflows/r-cmd-check.yaml/badge.svg)](https://github.com/luciorq/condathis/actions/workflows/r-cmd-check.yaml)
[![CRAN status](https://www.r-pkg.org/badges/version/condathis)](https://CRAN.R-project.org/package=condathis)
<!-- badges: end -->

> Run command-line tools in a **reproducible** and **isolated** way, right from R.

Tired of `system()` calls that work on your machine but break everywhere else?
`condathis` is here to help!
It lets you create self-contained environments for your command-line tools,
so your R code runs reliably for you, your colleagues, and your future self.

## A Quick Example

```{r}
#| label: clean-envs
#| eval: true
#| include: false
# Clean up any existing environments from previous runs
for (env_name in c("rich-cli-env", "cowpy-env", "fasqc-0.12.1", "curl-env")) {
  if (condathis::env_exists(env_name, verbose = "silent")) {
    condathis::remove_env(env_name, verbose = "silent")
  }
}
```

Let's have some fun with `cowpy`.
With just two commands, we can install and run it in its own isolated environment:

```{r}
#| label: cowpy-example
# 1. Install 'cowpy' into an environment named 'cowpy-env'
condathis::create_env(packages = "cowpy", env_name = "cowpy-env", verbose = "output")

# 2. Run it!
# Not working without stdin redirection - need to use a file as input
temp_file <- tempfile()
writeLines("{condathis} is awesome!", temp_file)
condathis::run("cowpy", stdin = temp_file, env_name = "cowpy-env", verbose = "output")
```

Maybe you want to try something fancier, like `rich-cli` for formatting messages?

```{r}
#| label: rich-cli-example
condathis::create_env(packages = "rich-cli", env_name = "rich-cli-env", verbose = "output")

condathis::run(
  "rich", "[b]Condathis[/b] is awesome!", "-p", "-a", "heavy",
  env_name = "rich-cli-env",
  verbose = "output"
)
```

That's it!
You can now package any command-line tool with your R script,
ensuring it works everywhere, every time.

## Get Started

Install the release version of the package from [CRAN](https://cran.r-project.org/package=condathis):

```{r}
#| label: install-cran
#| eval: false
install.packages("condathis")
```

Or get the development version from [R-Universe](https://luciorq.r-universe.dev/condathis):

```{r}
#| label: install-r-universe
#| eval: false
install.packages("condathis", repos = c("https://luciorq.r-universe.dev", getOption("repos")))
```

## Why `condathis`?

R's `system()` and `system2()` are powerful, but they depend on tools being
installed on the host system.
This creates a few problems:

* **Reproducibility:** Will your script from last year still work? Will your
  collaborator be able to run your code if they have a different version of a tool?
* **Conflicts:** What if two different tools need two different versions of the
  same dependency?

`{condathis}` solves these issues by creating isolated environments for each tool.

### Reproducibility: An Example

Let's say you're using `fastqc` for quality control in a bioinformatics pipeline.
Different versions of `fastqc` can produce slightly different results.

With `{condathis}`, you can lock in a specific version:

```{r}
#| label: fastqc-example
fastq_file <- system.file("extdata", "sample1_L001_R1_001.fastq.gz", package = "condathis")
temp_out_dir <- file.path(tempdir(), "output")
fs::dir_create(temp_out_dir)

# Always use fastqc version 0.12.1
condathis::create_env(packages = "fastqc==0.12.1", env_name = "fastqc-0.12.1")
condathis::run("fastqc", fastq_file, "-o", temp_out_dir, env_name = "fastqc-0.12.1")
```

Now your analysis will produce the same output files,
regardless of where or when it's run.

### Isolation: An Example

Need to use a specific version of a tool like `curl` that's different from your
system's version? No problem.

Your system's `curl`:

```{r}
#| label: curl-system-example
libcurlVersion()
```

A specific `curl` version, isolated with `condathis`:

```{r}
#| label: curl-condathis-example
condathis::create_env(
  packages = "curl==8.10.1",
  env_name = "curl-env",
  verbose = "output"
)

out <- condathis::run(
  "curl", "--version",
  env_name = "curl-env"
)

message(out$stdout)
```

This allows you to run tools with conflicting dependencies side-by-side without any issues.

## How It Works

The package `{condathis}` relies on [**`micromamba`**](https://mamba.readthedocs.io/en/latest/user_guide/micromamba.html) to bring **reproducibility and isolation**.
`micromamba` is a lightweight, fast, and efficient package manager that
"does not need a base environment and does not come with a default version of Python".

The integration of `micromamba` into `R` is handled using the `processx` and `withr` packages.

## Known Caveats

Special characters in CLI commands are interpreted as literals and not expanded.

* It is not supported the use of output redirections in commands, e.g. "|" or ">".
  * Instead of redirects (e.g. ">"), use the argument `stdout = "<FILENAME>.txt"`.
    Instead of Pipes ("|"), simple run multiple calls to `condathis::run()`,
    using `stdout` argument to control the output and `stdin` to control the input of each command.
    P.S. The current implementation only supports files as the "STDIN".
* File paths should not use special characters for relative paths, e.g. "~", ".", "..".
  * Expand file paths directly in R, using `base` functions
    or functions from the `fs` package.
